<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Prototype Map for 485</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />


  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- PapaParse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- MarkerCluster plugin -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Cormorant font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Cormorant:wght@400;500;600;700&display=swap">


  <style>
    :root {
      --card:  #fff9e8;
      --card2:#ffffff;
      --border: #c8bfb2;
      --accent: #6e4b3a;
      --hover-bg: #f9f5e9;
      --hover-bg2: #bea24d;
      --text: #2e2b28;
      --link: #3a4a5e;
    }
    
    header, #footer, .banner {
      color: black;
    }
    
    #footer a {
      color: black;
    }
    
    body {
      font-family: "Cormorant", serif;
      color: var(--text);
      margin: 0;
    }

    /* Layout: left vertical control bar + map content to the right. */
    body {
      display: flex;
    }

    header {
      box-sizing: border-box;
      background: var(--card);
      width: 400px;
      /* width of the left control bar */
      min-width: 240px;
      height: 100vh;
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
      background: var(--card);
      border-right: 1px solid var(--border);
      z-index: 1002;
      overflow-y: auto;
      overflow-x: hidden;
    }

    header::-webkit-scrollbar {
      width: 8px;
    }

    header::-webkit-scrollbar-thumb {
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }

    #brandFilter {
      padding: 8px;
      min-width: 160px;
      width: 100%;
    }

    /* push the map to the right so it doesn't sit underneath the fixed left bar */
    #map {
      margin-left: 400px;
      width: calc(100% - 400px);
      height: 100vh;
    }

    .popup {
      font-size: 1.05rem;
      line-height: 1.35;
    }

    #filtersPanel[hidden] {
      display: none !important;
    }

    #hamburger {
      font-size: 20px;
      font-family: "Cormorant", serif;
      background: var(--card2);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer
    }

    #filtersPanel {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .filters-panel {
      /* default: make the controls look like a card inside the left bar */
      position: relative;
      left: 0;
      top: 0;
      background: transparent;
      border: 0;
      padding: 0;
      box-shadow: none;
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
    }

    /* On small screens keep the original top-header behavior: make the header a normal top bar */
    @media(max-width:899px) {
      body {
        display: block;
      }

      header {
        position: static;
        width: 100%;
        height: auto;
        border-right: none;
        padding: 12px 16px;
        display: flex;
        flex-direction: row;
        align-items: center;
        background: var(--card);
        color: #fff;
      }

      #map {
        margin-left: 0;
        width: 100%;
        height: 640px;
      }

      .filters-panel {
        flex-direction: row;
        align-items: center;
        gap: 12px;
      }
    }

    .banner {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--card);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .06);
      z-index: 1000;
    }

    #top {
      /* This is for making the border-bottom span the entire width of the sidebar */
      margin-left: -18px;
      margin-right: -18px;
      border-bottom: 1px solid var(--border);
    }

    #top #inner {
      /* This allows the text within the top div to maintain the same padding as the rest of the sidebar */
      padding-left: 18px;
      padding-right: 18px;
    }

    #storeListContainer {
      flex: 1 1 auto;
      overflow-y: auto;
      width: 100%;
      box-sizing: border-box;
      padding-bottom: 0.5rem;
    }

    .store {
      /* Will change colors if necessary */
      background-color: var(--card2);
      border: 1px solid var(--border);
      color: var(--text);

      border-radius: 6px;
      padding: 0.5rem;
      margin-bottom: 0.5rem;  
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      transition: background-color 0.2s, box-shadow 0.2s;
    }

    .store:hover {
      background-color: var(--hover-bg);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);

    }

    .hidden {
      display: none !important;
    }

    #footer {
      /* This fixes the footer div to the bottom of the sidebar */
      flex: none;
      margin-top: auto;
      margin-left: -10px;
      /* padding: top right bottom left */
      padding: 10px 10px 5px 10px;
      border-top: 1px solid var(--border);
      box-sizing: border-box;
      width: calc(100% + 36px);
      background: var(--card);
    }

    #storeCheckboxes input[type="checkbox"] {
      accent-color: var(--accent);
      cursor: pointer;
      margin-right: 6px;
    }

    #storeCheckboxes label {
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 2px 0;
    }

    #storeCheckboxes input[type="checkbox"]:checked+label,
    #storeCheckboxes input[type="checkbox"]:checked {
      color: var(--accent);
      font-weight: 600;
    }

    /* Store detail panel */
    .store-detail {
      width: 100%;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      box-sizing: border-box;
      margin-top: 10px;
    }
          
    .store-detail.hidden {
      display: none !important;
    }
    
    .store-detail__top {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .store-detail__title {
      font-size: 1.2rem;
      font-weight: 700;
      line-height: 1.2;
      text-transform: uppercase;
    }
    
    .store-detail__close {
      border: 1px solid var(--border);
      background: var(--card2);
      border-radius: 8px;
      width: 34px;
      height: 34px;
      cursor: pointer;
      font-size: 20px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .store-detail__image {
      width: 100%;
      height: 180px;
      background: #e9e4d6;
      border: 1px solid var(--border);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      margin-bottom: 10px;
    }
    
    .store-detail__imageText {
      font-size: 1rem;
      opacity: 0.8;
    }
    
    .store-detail__actions {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
    }
    
    .store-detail__btn {
      flex: 1;
      text-align: center;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: var(--card2);
      color: var(--text);
      text-decoration: none;
      cursor: pointer;
      font-weight: 600;
    }
    
    .store-detail__btn:hover {
      background: var(--hover-bg);
    }
    
  .store-detail__section {
    padding-top: 10px;
    border-top: 1px solid var(--border);
    margin-top: 10px;
  }
  
  .store-detail__label {
    font-weight: 700;
    margin-bottom: 6px;
  }
  
  .store-detail__value {
    font-size: 1rem;
    line-height: 1.3;
    word-break: break-word;
  }

  </style>
</head>

<body>
  <header>

    <div id="top">
      <div id="inner">
        <h2>WatchDNA's Network | Find jewellers in your area</h2>
        <p>As your trusted directory for brands and authorized dealers, we make it easy to find and reach out to
          Authorized Dealers. (Please note that only select authorized dealers will be featured under our brand
          filters.)
        </p>
      </div>
    </div>

    <button id="hamburger" aria-expanded="false" aria-controls="filtersPanel" title="Show filters">
      ‚ò∞ Filter
    </button>
    <div id="filtersPanel" class="filters-panel" hidden>
      <label for="brandFilter"><strong>Filter by brand:</strong></label>
      <select id="brandFilter">
        <option value="">All brands</option>
      </select>
      <label for="typeFilter" style="margin-left:12px"><strong>Type:</strong></label>
      <select id="typeFilter" style="padding:8px;">
        <option value="all">All</option>
        <option value="retailer">Retailers</option>
        <option value="boutique">Boutiques</option>
        <option value="mall location">Mall Locations</option>
        <option value="other">Other</option>
      </select>
      <label for="storeFilter" style="margin-left:12px"><strong>Filter by store:</strong></label>
      <input id="storeFilter" type="search" placeholder="Search By Store Name" style="padding:8px; min-width:260px;" />
      <div id="storeCheckboxes"
        style="margin-top:10px; max-height:200px; overflow-y:auto; border:1px solid var(--border); padding:8px; border-radius:6px;">
        <!-- Store name checkboxes -->
      </div>
        <input type="checkbox" id="premiumOnlyToggle" style="cursor:pointer; transform: scale(1.2);" />
        <label for="premiumOnlyToggle" style="cursor:pointer;"><strong>Show Premium Only</strong></label>
      </div>
      <div style="margin-top:10px; display:flex; align-items:center; gap:8px;"></div>
      <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
        <button id="nearMeBtn" title="Share your location to find the closest store"
          style="padding:8px 10px; border:1px solid var(--border); border-radius:6px; cursor:pointer;">
          üìç Near me
        </button>
        <span id="nearMeStatus" style="font-size:.9rem; opacity:.8;"></span>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <select id="nearMeRadius" style="padding:6px; border:1px solid var(--border); border-radius:6px;">
          <option value="5">5 mi</option>
          <option value="10" selected>10 mi</option>
          <option value="25">25 mi</option>
          <option value="50">50 mi</option>
        </select>
        <button id="nearMeWithinBtn" title="Show stores within radius"
          style="padding:8px 10px; border:1px solid var(--border); border-radius:6px; cursor:pointer;">
          Within radius
        </button>
      </div>
    </div>

    <!-- Store detail panel (hidden by default)-->
     <div id="storeDetailPanel" class="store-detail hidden" aria-hidden="true">
      <div class="store-detail__top">
        <div class="store-detail__title" id="detailName">Store Name</div>
        <button class="store-detail__close" id="detailCloseBtn" aria-label="Close">√ó</button>
      </div>

      <div class="store-detail__image" id="detailImage" role="img" aria-label="Store image placeholder">
        <div class="store-detail__imageText">Image placeholder</div>
      </div>

      <div class="store-detail__actions">
        <a id="detailDirectionsBtn" class="store-detail__btn" href="#" target="_blank" rel="noopener">Directions</a>
        <a id="detailConnectBtn" class="store-detail__btn" href="#">Connect</a>
      </div>

      <div class="store-detail__section">
        <div class="store-detail__label">Address</div>
        <div class="store-detail__value" id="detailAddress"></div>
      </div>

      <div class="store-detail__section">
        <div class="store-detail__label">Phone</div>
        <div class="store-detail__value" id="detailPhone"></div>
      </div>

      <div class="store-detail__section">
        <div class="store-detail__label">Brands</div>
        <div class="store-detail__value" id="detailBrands"></div>
        </div>
      </div>

    <div id="storeListContainer">
      <div id="storeListings"></div>
    </div>

    <div id="footer">
      <a href="https://watchdna.com/tools/storelocator/directory">Store Directory</a>
    </div>

  </header>

  <div id="map"></div>

  <script>
    // --- Map bootstrap ---
    const map = L.map('map');
    map.setView([20, 0], 2); // will be replaced by fitBounds if we have data

    // For zoom out logic
    const originalCenter = map.getCenter();
    const originalZoom = map.getZoom();

    map.on('popupclose', () => {
      resetFocusedStore();
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // --- URL parameter helpers (CSV + initial filters) ---
    const params = new URLSearchParams(window.location.search);
    const INITIAL = {
      brand: params.get('brand') || '',
      type: params.get('type') || 'all',
      store: params.get('store') || ''
    };
    console.log('[proto] initial filters:', INITIAL);

    // --- CSV loader (with cache-busting to avoid stale results) ---
    function loadCSV(path) {
      const url = `${path}?v=${Date.now()}`;
      return new Promise((resolve, reject) => {
        Papa.parse(url, {
          download: true,
          header: true,
          skipEmptyLines: true,
          complete: res => resolve(res.data),
          error: err => reject(err)
        });
      });
    }

    // --- small hamburger toggle (left) ---
    (function () {
      const btn = document.getElementById('hamburger');
      const panel = document.getElementById('filtersPanel');
      const storeListContainer = document.getElementById('storeListContainer');

      if (!btn || !panel || !storeListContainer) {
        console.warn('Toggle init aborted, missing elements:', { btn, panel, storeListContainer });
        return;
      }

      function setStoreListHidden(hidden) {
        // keep a class for CSS transitions or style hooks
        if (hidden) {
          storeListContainer.classList.add('hidden');
          //set inline style to be extra sure
          storeListContainer.style.display = 'none';
        }
        else {
          storeListContainer.classList.remove('hidden');
          storeListContainer.style.display = '';
        }
        console.log('[storeList] set hidden =', hidden, 'classList:', storeListContainer.className);
      }

      btn.addEventListener('click', (e) => {
        const wasHidden = panel.hasAttribute('hidden');

        if (wasHidden) {
          //opening the Filters panel
          panel.removeAttribute('hidden');
          btn.setAttribute('aria-expanded', 'true');
          setStoreListHidden(true); //hide the store list
        }
        else {
          //closing the Filters panel
          panel.setAttribute('hidden', '');
          btn.setAttribute('aria-expanded', 'false');
          setStoreListHidden(false); //show the store list
        }
        e.stopPropagation();
      });
      document.addEventListener('click', (ev) => {
        if (!panel.hasAttribute('hidden') && !panel.contains(ev.target) && ev.target !== btn) {
          panel.setAttribute('hidden', '');
          btn.setAttribute('aria-expanded', 'false');
          setStoreListHidden(false);
          console.log('[document] closed filters by click outside');
        }
      });
    })();

    // --- Clustering & filtering state ---
    const clusterGroup = L.markerClusterGroup();
    const bounds = L.latLngBounds();
    let allRows = [];
    let allMarkers = [];

    // Temporary Icons for regular and premium vendors
    const regularIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34]
    });

    const premiumIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-gold.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34]
    });

    function buildPopup(row) {
      const addr = [row['Address Line 1'], row['City'], row['State/Province/Region'], row['Country']]
        .filter(Boolean).join(', ');
      const phone = row['Phone'] ? `<br>${row['Phone']}` : '';
      
      // Get brands from Brands column first, fallback to Custom Brands if empty
      let brands = (row['Brands'] || '').trim();
      if (!brands && row['Custom Brands']) {
        // Extract brand names from HTML Custom Brands column
        const customBrandsHtml = row['Custom Brands'];
        const brandMatches = customBrandsHtml.match(/>([^<]+)<\/A>/gi) || [];
        brands = brandMatches.map(m => m.replace(/>|<\/A>/gi, '').trim()).filter(Boolean).join(', ');
      }
      
      const brandsDisplay = brands ? `<br><br><strong>Brands:</strong> ${brands}` : '';
      return `<div class="popup"><b>${row['Name'] || ''}</b><br>${addr}${phone}${brandsDisplay}</div>`;
    }
    
    function buildFullAddress(row) {
      const line1 = (row['Address Line 1'] || '').trim();
      const line2 = (row['Address Line 2'] || '').trim();
      const city = (row['City'] || '').trim();
      const state = (row['State/Province/Region'] || '').trim();
      const zip = (row['Zip/Postal Code'] || '').trim();
      const country = (row['Country'] || '').trim();
      
      const parts = [];
      if (line1) parts.push(line1);
      if (line2) parts.push(line2);
      
      const cityLine = [city, state, zip].filter(Boolean).join(', ');
      if (cityLine) parts.push(cityLine);
      if (country) parts.push(country);
      
      return parts.join('\n');
    }
    
    function extractBrandsText(row) {
      let brands = (row['Brands'] || '').trim();
      
      if (!brands && row['Custom Brands']) {
        const customBrandsHtml = row['Custom Brands'];
        const brandMatches = customBrandsHtml.match(/>([^<]+)<\/A>/gi) || [];
        brands = brandMatches
        .map(m => m.replace(/>|<\/A>/gi, '').trim())
        .filter(Boolean)
        .join(', ');
      }
      
      return brands;
    }

    function setDetailPanelVisible(visible) {
      const panel = document.getElementById('storeDetailPanel');
      const listContainer = document.getElementById('storeListContainer');
      if (!panel || !listContainer) return;

      if (visible) {
      panel.classList.remove('hidden');
      panel.setAttribute('aria-hidden', 'false');
      listContainer.classList.add('hidden');
      listContainer.style.display = 'none';
    } else {
      panel.classList.add('hidden');
      panel.setAttribute('aria-hidden', 'true');
      listContainer.classList.remove('hidden');
      listContainer.style.display = '';
    }
  }

  function openStoreDetail(row, marker) {
    const nameEl = document.getElementById('detailName');
    const addressEl = document.getElementById('detailAddress');
    const phoneEl = document.getElementById('detailPhone');
    const brandsEl = document.getElementById('detailBrands');
    const directionsBtn = document.getElementById('detailDirectionsBtn');
    const connectBtn = document.getElementById('detailConnectBtn');

    const name = (row['Name'] || 'Unnamed').trim();
    const address = buildFullAddress(row);
    const phone = (row['Phone'] || '').trim();
    const brands = extractBrandsText(row);

    if (nameEl) nameEl.textContent = name;

    if (addressEl) {
      addressEl.textContent = address || 'Not provided';
      addressEl.style.whiteSpace = 'pre-line';
    }

    if (phoneEl) phoneEl.textContent = phone || 'Not provided';
    if (brandsEl) brandsEl.textContent = brands || 'Not provided';

    // Directions: use lat/lng if available, otherwise fall back to address
    const lat = parseFloat(String(row.Latitude || '').trim());
    const lon = parseFloat(String(row.Longitude || '').trim());
    const hasCoords = Number.isFinite(lat) && Number.isFinite(lon);

    if (directionsBtn) {
    const q = hasCoords ? `${lat},${lon}` : encodeURIComponent(address.replace(/\n/g, ', '));
    directionsBtn.href = hasCoords
      ? `https://www.google.com/maps/search/?api=1&query=${q}`
      : `https://www.google.com/maps/search/?api=1&query=${q}`;
    }

    // Connect: prefer email; otherwise disable
    const email = (row['Email'] || '').trim();
    if (connectBtn) {
      if (isValidEmail(email)) {
        connectBtn.href = `mailto:${email}`;
        connectBtn.textContent = 'Connect';
        connectBtn.style.opacity = '1';
        connectBtn.style.pointerEvents = 'auto';
      } else {
        connectBtn.href = '#';
        connectBtn.textContent = 'Connect';
        connectBtn.style.opacity = '0.5';
        connectBtn.style.pointerEvents = 'none';
      }
    }
    
    setDetailPanelVisible(true);

    // Optional: keep the map movement consistent
    if (marker && hasCoords) {
      map.flyTo([lat, lon], 14, { animate: true, duration: 0.8 });
    }
  }

  //Zooms the map out to full view
  function resetFocusedStore() {
    setDetailPanelVisible(false);

    if(originalCenter && originalZoom !== undefined) {
      map.flyTo(originalCenter, originalZoom, {
        animate: true,
        duration: 0.8
      });
    }
  }

  // When the close store detail button is clicked, it will close itself, the popup, and zoom the map back out to full view
  const closeBtn = document.getElementById('detailCloseBtn');
  if(closeBtn) {
    closeBtn.addEventListener('click', () => {
      map.closePopup();
    });
  }

    function rebuildStoreCheckboxes(rowsForList) {
      // rowsForList should be the rows after applying non-checkbox filters
      const storeCheckboxesDiv = document.getElementById('storeCheckboxes');

      // preserve which store names were checked before rebuild
      const prevChecked = new Set(
        Array.from(storeCheckboxesDiv.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value)
      );

      storeCheckboxesDiv.innerHTML = '';

      const storeNames = [...new Set(rowsForList.map(r => (r['Name'] || '').trim()).filter(Boolean))].sort();

      const premiumOnly = document.getElementById('premiumOnlyToggle')?.checked;

      storeNames.forEach(name => {
        const rowMatch = rowsForList.find(r => (r['Name'] || '').trim() === name);

        // Skip non-premium rows entirely in checkbox list
        if (premiumOnly && !rowMatch?._isPremium) return;

        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '8px';
        label.style.padding = '2px 0';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = name;
        cb.checked = prevChecked.has(name);
        cb.addEventListener('change', () => applyFilter(document.getElementById('brandFilter').value));

        const span = document.createElement('span');
        span.textContent = name;
        span.style.userSelect = 'none';

        label.appendChild(cb);
        label.appendChild(span);
        storeCheckboxesDiv.appendChild(label);
      });
    }

    // Sync the "Filter by store" checkbox list with the rows that passed ALL filters
    function syncStoreCheckboxes(filteredRows) {
      const allowed = new Set(
        filteredRows.map(r => (r['Name'] || '').trim().toLowerCase())
      );

      const q = (document.getElementById('storeFilter').value || '')
        .trim().toLowerCase();

      // Walk all checkbox rows in the list
      document.querySelectorAll('#storeCheckboxes label').forEach(label => {
        const cb = label.querySelector('input[type="checkbox"]');
        const name = (label.querySelector('span')?.textContent || cb.value || '')
          .trim().toLowerCase();

        const inFiltered = allowed.has(name);

        // Show/hide entries that are not part of the current filtered set
        label.style.display = inFiltered ? '' : 'none';

        // If a store text filter exists, auto-check matches; otherwise uncheck hidden
        if (q) {
          cb.checked = inFiltered && name.includes(q);
        } else if (!inFiltered) {
          cb.checked = false;
        }
      });
    }

    function applyFilter(brand) {
      clusterGroup.clearLayers();

      const brandValue = (brand || '').trim().toUpperCase();
      const typeValue = (document.getElementById('typeFilter').value || 'all');
      const storeInput = (document.getElementById('storeFilter').value || '').trim().toLowerCase();
      // Premium-only filter
      const premiumOnly = document.getElementById('premiumOnlyToggle').checked;

      const baseRows = [];
      allMarkers.forEach(({ row }) => {
        let passes = true;

        // brand filter - check Brands column (plain text, comma-separated)
        if (brandValue) {
          const brands = (row['Brands'] || '')
            .toUpperCase()
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
          passes = brands.includes(brandValue);
        }

        // store text search
        if (passes && storeInput) {
          if (storeInput.startsWith('handle:')) {
            const h = storeInput.split(':', 2)[1] || '';
            passes = (String(row['Handle'] || '') === h);
          } else {
            passes = (String(row['Name'] || '').toLowerCase().includes(storeInput));
          }
        }

        // type filter
        if (passes && typeValue && typeValue !== 'all') {
          passes = (String(row._type || 'retailer') === typeValue);
        }

        // Premium-only logic
        if (passes && premiumOnly) {
          passes = row._isPremium === true;
        }

        if (passes) baseRows.push(row);
      });

      rebuildStoreCheckboxes(baseRows);
      syncStoreCheckboxes(baseRows);


      const checkedStores = Array.from(document.querySelectorAll('#storeCheckboxes input[type="checkbox"]:checked')).map(cb => cb.value.toLowerCase());

      const baseNameSet = new Set(baseRows.map(r => (r['Name'] || '').trim().toLowerCase()));

      allMarkers.forEach(({ row, marker }) => {
        const nameLower = (row['Name'] || '').trim().toLowerCase();
        let show = baseNameSet.has(nameLower); // only show if it matched non-checkbox filters

        if (show && checkedStores.length > 0) {
          show = checkedStores.includes(nameLower);
        }

        if (show) clusterGroup.addLayer(marker);
      });
    }

    // --- Near Me radius filter ---

    let radiusCircle = null;

    function meters(mi) { return mi * 1609.344; }

    function applyRadiusToCurrent(centerLL, radiusMeters) {
      if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
      radiusCircle = L.circle(centerLL, { radius: radiusMeters, fillOpacity: 0.07 }).addTo(map);

      // Start from your existing filtered set
      const brandValue = (document.getElementById('brandFilter').value || '');
      applyFilter(brandValue);

      // Filter only visible markers within the radius
      const current = clusterGroup.getLayers();
      clusterGroup.clearLayers();
      let kept = 0;
      current.forEach(m => {
        const d = map.distance(centerLL, m.getLatLng());
        if (d <= radiusMeters) { clusterGroup.addLayer(m); kept++; }
      });

      setNearMeStatus(`Showing ${kept} location(s) within ${(radiusMeters / 1609.344).toFixed(0)} mi`);
      if (kept > 0) map.fitBounds(radiusCircle.getBounds().pad(0.2));
    }

    function locateAndFilterWithinRadius() {
      if (!navigator.geolocation) { setNearMeStatus('Geolocation not supported.'); return; }
      setNearMeStatus('Locating‚Ä¶');
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const ll = toLatLng(pos.coords.latitude, pos.coords.longitude);
          showUserMarker(ll);
          const mi = parseFloat(document.getElementById('nearMeRadius').value || '10');
          applyRadiusToCurrent(ll, meters(mi));
        },
        () => setNearMeStatus('Unable to get location.'),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
      );
    }

    // --- Near Me helpers ---
    let userMarker = null
    let nearestLine = null;
    let nearestMarker = null;

    function setNearMeStatus(msg) {
      const el = document.getElementById('nearMeStatus');
      if (el) el.textContent = msg || '';
    }

    function toLatLng(lat, lng) { return L.latLng(lat, lng); }

    function findNearest(targetLatLng) {
      let best = null; // { dist, row, marker }
      allMarkers.forEach(({ row, marker }) => {
        const d = map.distance(targetLatLng, marker.getLatLng());
        if (!best || d < best.dist) best = { dist: d, row, marker };
      });
      return best;
    }

    function emphasizeNearest(userLL, best) {
      if (nearestLine) { map.removeLayer(nearestLine); nearestLine = null; }
      if (nearestMarker) { nearestMarker.setZIndexOffset(0); nearestMarker = null; }
      if (!best) { setNearMeStatus('No locations loaded.'); return; }

      nearestMarker = best.marker;
      const row = best.row || getRowForMarker(nearestMarker);

      nearestMarker.setZIndexOffset(1000);
      nearestLine = L.polyline([userLL, nearestMarker.getLatLng()], { weight: 3, dashArray: '6,6' }).addTo(map);

      const dist = map.distance(userLL, nearestMarker.getLatLng());
      const miles = (best.dist / 1609.344).toFixed(2);
      const km = (best.dist / 1000).toFixed(2);
      const b = L.latLngBounds([userLL, best.marker.getLatLng()]).pad(0.4);
      map.fitBounds(b);

      setNearMeStatus(`Closest: ${(row['Name'] || 'Location')} ‚Äî ${miles} mi / ${km} km`);
      nearestMarker.openPopup();
    }

    function showUserMarker(ll) {
      if (userMarker) userMarker.setLatLng(ll);
      else userMarker = L.marker(ll, { title: 'You are here' })
        .bindPopup('<b>You are here</b>')
        .addTo(map);

      L.circle(ll, { radius: 25, stroke: false, fillOpacity: 0.15 }).addTo(map);
    }

    // Return the markers currently visible after applyFilter()
    function getVisibleMarkers() {
      return clusterGroup.getLayers(); // array of L.Marker
    }

    // Lookup the original row for a given marker
    function getRowForMarker(marker) {
      const rec = allMarkers.find(x => x.marker === marker);
      return rec ? rec.row : {};
    }

    // Find the nearest marker among a given set (visible layers)
    function findNearestAmong(targetLatLng, layers) {
      let best = null; // { dist, marker }
      layers.forEach(m => {
        const d = map.distance(targetLatLng, m.getLatLng());
        if (!best || d < best.dist) best = { dist: d, marker: m };
      });
      return best;
    }

    function locateAndJumpToNearest() {
      if (!navigator.geolocation) { setNearMeStatus('Geolocation not supported.'); return; }
      setNearMeStatus('Locating‚Ä¶');
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const userLL = toLatLng(pos.coords.latitude, pos.coords.longitude);
          showUserMarker(userLL);

          // Ensure we're using the current filtered set (whatever UI is set to)
          const brandValue = (document.getElementById('brandFilter').value || '');
          applyFilter(brandValue); // keeps current type/store filters

          const visible = getVisibleMarkers();
          if (!visible.length) { setNearMeStatus('No locations match current filters.'); return; }

          const best = findNearestAmong(userLL, visible);
          // Include row for nicer status text
          emphasizeNearest(userLL, { ...best, row: getRowForMarker(best.marker) });
        },
        (err) => {
          const m = { 1: 'Permission denied.', 2: 'Position unavailable.', 3: 'Request timed out.' };
          setNearMeStatus(m[err.code] || 'Unable to get location.');
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
      );
    }

    function populateBrandSelect(brandSet) {
      const sel = document.getElementById('brandFilter');
      while (sel.options.length > 1) sel.remove(1);
      [...brandSet].sort().forEach(b => {
        const opt = document.createElement('option');
        opt.value = b; opt.textContent = b; sel.appendChild(opt);
      });
      sel.onchange = () => applyFilter(sel.value);
      // wire type select
      const typeSel = document.getElementById('typeFilter');
      typeSel.onchange = () => applyFilter(sel.value);
      // wire store filter input (debounced)
      const storeInput = document.getElementById('storeFilter');
      let debounce;
      storeInput.addEventListener('input', () => {
        clearTimeout(debounce);
        debounce = setTimeout(() => applyFilter(sel.value), 250);
      });
    }

    function showBanner(msg) {
      const div = document.createElement('div');
      div.className = 'banner';
      div.textContent = msg;
      document.body.appendChild(div);
    }

    function isValidEmail(val) {
      if (!val) return false;

      const bad = new Set([
        '', ' ', '-', '--', '---', '.', 'n/a', 'na', 'none', 'null',
        'not provided', 'not available', 'no email', '0'
    ]);

    const cleaned = val.trim().toLowerCase();
    if (bad.has(cleaned)) return false;

    return cleaned.includes('@') && cleaned.includes('.');
    }

    // --- Load data & render (with helpful logs) ---
    loadCSV('backend/uploads/master_stores.csv')
      .then(rows => {
        console.log('CSV rows (raw):', rows.length);
        const brandSet = new Set();

        // Keep only rows that *have something* in lat/lon
        allRows = rows.filter(r => (r.Latitude ?? '') !== '' && (r.Longitude ?? '') !== '');
        console.log('Rows with any lat/lon value:', allRows.length);

        const detailCloseBtn = document.getElementById('detailCloseBtn');
        if (detailCloseBtn) {
          detailCloseBtn.addEventListener('click', () => setDetailPanelVisible(false));
        }

        allRows.forEach(row => {
          // classify row as 'accessory' or 'retailer' using simple heuristics
          // - if any descriptive field contains the word 'accessor' treat as accessory
          // - otherwise default to retailer
          const descFields = [row['Name'], row['Page Description'], row['Page Title'], row['Meta Description'], row['Tags'], row['Custom Brands']]
            .filter(Boolean)
            .join('\n')
            .toLowerCase();

          if (/boutique/.test(descFields)) {
            row._type = 'boutique';
          } else if (/mall|shopping center|plaza/.test(descFields)) {
            row._type = 'mall location';
          } else if (/authorized dealer|retailer|store/.test(descFields)) {
            row._type = 'retailer';
          } else {
            row._type = 'other';
          }
          const lat = parseFloat(String(row.Latitude).trim());
          const lon = parseFloat(String(row.Longitude).trim());
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

          row._isPremium = isValidEmail(row['Email']);

          const iconToUse = row._isPremium ? premiumIcon : regularIcon;

          const marker = L.marker([lat, lon], { icon: iconToUse })
            .bindPopup(buildPopup(row));
            marker.on('click', () => {
              openStoreDetail(row, marker);
              });
          allMarkers.push({ row, marker });
          clusterGroup.addLayer(marker);
          bounds.extend([lat, lon]);

          // Extract brands from Brands column (plain text, comma-separated)
          (row['Brands'] || '')
            .split(',')
            .map(s => s.trim())
            .filter(Boolean)
            .forEach(b => brandSet.add(b));
          // also expose type values for debugging / UI
          // (we don't include types in the brand list)

        });

        map.addLayer(clusterGroup);

        const NearMeControl = L.Control.extend({
          options: { position: 'bottomright' },

          onAdd: function (map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
            container.style.backgroundColor = 'white';
            container.style.border = '1px solid #ccc';
            container.style.borderRadius = '6px';
            container.style.cursor = 'pointer';
            container.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
            container.style.padding = '6px 10px';
            container.style.fontSize = '16px';
            container.style.display = 'flex';
            container.style.alignItems = 'center';
            container.style.justifyContent = 'center';
            container.title = 'Find stores near me';
            container.innerHTML = 'üìç Near Me';

            // Prevent map from zooming when clicking the control
            L.DomEvent.disableClickPropagation(container);

            container.addEventListener('click', () => {
              locateAndJumpToNearest();
            });

            return container;
          }
        });

        map.addControl(new NearMeControl());

        if (bounds.isValid()) map.fitBounds(bounds.pad(0.2));

        // Building the sidebar list
        const storeList = document.getElementById('storeListings');
        storeList.innerHTML = '';

        allMarkers.forEach(({ row, marker }) => {
          const item = document.createElement('div');
          item.className = 'store';

          const addressLine = row['Address Line 1'] || '';

          const locationParts = [
            row['City'],
            row['State/Province/Region'],
            row['Country']
          ].filter(Boolean); // Will remove undefined or empty strings (mainly for locations that don't have a State/Province/Region)

          // Join the pieces of the address with commas
          const locationLine = locationParts.join(', ');

          item.innerHTML = `
          <strong>${row['Name'] || 'Unamed'}</strong><br>
          ${addressLine}<br>
          ${locationLine}
          `;

          item.addEventListener('click', () => {
            // Pan to location on map and open its associated popup
            // two lines to add lat and lon to variables but within this function there are already those so just going to use those
            const latitude = parseFloat(row.Latitude);
            const longitude = parseFloat(row.Longitude);

            if (Number.isFinite(latitude) && Number.isFinite(longitude)) {
              map.flyTo([latitude, longitude], 14, { animate: true, duration: 0.8 });
            }

            openStoreDetail(row, marker);
          });

          storeList.appendChild(item);
        });

        const RadiusControl = L.Control.extend({
          options: { position: 'bottomright' },

          onAdd: function (map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
            container.style.backgroundColor = 'white';
            container.style.border = '1px solid #ccc';
            container.style.borderRadius = '6px';
            container.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
            container.style.padding = '8px';
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.gap = '6px';
            container.style.fontSize = '14px';
            container.title = 'Show stores within a radius of your location';

            // Prevent clicks from affecting map zoom/pan
            L.DomEvent.disableClickPropagation(container);

            // Radius dropdown
            const select = L.DomUtil.create('select', '', container);
            select.style.padding = '4px';
            select.style.borderRadius = '4px';
            select.style.border = '1px solid #ccc';
            select.style.cursor = 'pointer';

            [5, 10, 25, 50].forEach(mi => {
              const opt = document.createElement('option');
              opt.value = mi;
              opt.textContent = `${mi} mi`;
              if (mi === 10) opt.selected = true;
              select.appendChild(opt);
            });

            // "Within radius" button
            const button = L.DomUtil.create('button', '', container);
            button.textContent = 'Within radius';
            button.style.padding = '6px 8px';
            button.style.border = '1px solid #ccc';
            button.style.borderRadius = '4px';
            button.style.cursor = 'pointer';
            button.style.background = 'white';

            // Click handler
            button.addEventListener('click', () => {
              const mi = parseFloat(select.value || '10');
              const radiusMeters = mi * 1609.344;

              if (!navigator.geolocation) {
                setNearMeStatus('Geolocation not supported.');
                return;
              }

              setNearMeStatus(`Locating...`);
              navigator.geolocation.getCurrentPosition(
                pos => {
                  const ll = L.latLng(pos.coords.latitude, pos.coords.longitude);
                  showUserMarker(ll);
                  applyRadiusToCurrent(ll, radiusMeters);
                },
                () => setNearMeStatus('Unable to get location.'),
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
              );
            });

            return container;
          }
        });

        map.addControl(new RadiusControl());
        populateBrandSelect(brandSet);
        rebuildStoreCheckboxes(allRows);
        // Premium Only Toggle Listener
        document.getElementById('premiumOnlyToggle')
          .addEventListener('change', () => {
            const premiumOnly = document.getElementById('premiumOnlyToggle').checked;

            // Clear all checkboxes when premium-only is enabled
            if (premiumOnly) {
              document.querySelectorAll('#storeCheckboxes input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
              });
            }

            applyFilter(document.getElementById('brandFilter').value);
          });

        // Preload filters from URL, then apply once
        document.getElementById('brandFilter').value = INITIAL.brand;
        document.getElementById('typeFilter').value = INITIAL.type;
        document.getElementById('storeFilter').value = INITIAL.store;
        applyFilter(INITIAL.brand);

        // --- Sync checkboxes to match URL store filter ---
        if (INITIAL.store) {
          const filterValue = INITIAL.store.toLowerCase();
          document.querySelectorAll('#storeCheckboxes input[type="checkbox"]').forEach(cb => {
            const label = cb.parentElement.querySelector('span')?.textContent?.toLowerCase() || '';
            cb.checked = label.includes(filterValue);
          });
        }

        const nearBtn = document.getElementById('nearMeBtn');
        if (nearBtn) nearBtn.addEventListener('click', locateAndJumpToNearest);

        const withinBtn = document.getElementById('nearMeWithinBtn');
        if (withinBtn) withinBtn.addEventListener('click', locateAndFilterWithinRadius);

        console.log('Markers added:', allMarkers.length);
        if (allMarkers.length === 0) {
          showBanner('No markers loaded ‚Äî check that master_stores.csv has data rows with numeric Latitude/Longitude.');
        }
      })
      .catch(err => {
        console.error('Error loading CSV:', err);
        alert('Failed to load master_stores.csv. Serve via http://localhost and ensure the CSV file exists at backend/uploads/master_stores.csv.');
      });
  </script>
</body>

</html>
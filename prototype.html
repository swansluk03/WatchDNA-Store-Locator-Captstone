<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Prototype Map for 485</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />


  <!-- Leaflet core -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- PapaParse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- MarkerCluster plugin -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
  />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    :root { --card:#fff; --border:#d0d7de; }
    body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    /* Layout: left vertical control bar + map content to the right. */
    body { display: flex; }
    header {
      box-sizing: border-box;
      width: 320px; /* width of the left control bar */
      min-width: 240px;
      height: 100vh;
      position: fixed;
      left: 0; top: 0; bottom: 0;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
      background: var(--card);
      border-right: 1px solid var(--border);
      z-index: 1002;
    }
    #brandFilter { padding: 8px; min-width: 160px; width:100%; }
    /* push the map to the right so it doesn't sit underneath the fixed left bar */
    #map { margin-left: 320px; width: calc(100% - 320px); height: 100vh; }
    .popup { font-size: 1.05rem; line-height: 1.35; }
   
   #filtersPanel[hidden] { display: none !important; }
    #hamburger { font-size: 20px; background: var(--card); border: 1px solid var(--border); padding:6px 10px; border-radius:6px; cursor:pointer }
    #filtersPanel { display:flex; gap:12px; align-items:center; }
    .filters-panel { /* default: make the controls look like a card inside the left bar */
      position: relative; left: 0; top: 0; background:transparent; border:0; padding:0; box-shadow:none;
      display: flex; flex-direction: column; gap:10px; width:100%;
    }
    /* On small screens keep the original top-header behavior: make the header a normal top bar */
    @media(max-width:899px){
      body { display: block; }
      header {
        position: static; width:100%; height:auto; border-right: none; padding: 12px 16px; display:flex; flex-direction:row; align-items:center;
      }
      #map { margin-left: 0; width: 100%; height: 640px; }
      .filters-panel { flex-direction: row; align-items: center; gap:12px; }
    }
  .banner {
      position: absolute; top: 10px; right: 10px; background: var(--card);
      border: 1px solid var(--border); padding: 8px 12px; border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,.06); z-index: 1000;
    }
  </style>
</head>
<body> 
<header>
    <button id="hamburger" aria-expanded="false" aria-controls="filtersPanel" title="Show filters">‚ò∞</button>
    <div id="filtersPanel" class="filters-panel" hidden>
      <label for="brandFilter"><strong>Filter by brand:</strong></label>
      <select id="brandFilter">
        <option value="">All brands</option>
      </select>
      <label for="typeFilter" style="margin-left:12px"><strong>Type:</strong></label>
      <select id="typeFilter" style="padding:8px;">
        <option value="all">All</option>
        <option value="retailer">Retailers</option>
        <option value="accessory">Accessories</option>
      </select>
      <label for="storeFilter" style="margin-left:12px"><strong>Filter by store:</strong></label>
      <input id="storeFilter" type="search" placeholder="Store name or handle (handle:asu-test)" style="padding:8px; min-width:260px;" />
      <label for="accessoryOnly" style="margin-left:12px"><strong>Accessories only</strong></label>
      <input id="accessoryOnly" type="checkbox" title="Show only accessory locations" style="width:18px; height:18px;" />
      <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
        <button id="nearMeBtn" title="Share your location to find the closest store" style="padding:8px 10px; border:1px solid var(--border); border-radius:6px; cursor:pointer;">
          üìç Near me
          </button>
          <span id="nearMeStatus" style="font-size:.9rem; opacity:.8;"></span>
        </div>
    </div>
  </header>

  <div id="map"></div>

  <script>
    // --- Map bootstrap ---
    const map = L.map('map');
    map.setView([20, 0], 2); // will be replaced by fitBounds if we have data

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // --- CSV loader (with cache-busting to avoid stale results) ---
    function loadCSV(path) {
      const url = `${path}?v=${Date.now()}`;
      return new Promise((resolve, reject) => {
        Papa.parse(url, {
          download: true,
          header: true,
          skipEmptyLines: true,
          complete: res => resolve(res.data),
          error: err => reject(err)
        });
      });
    }

    // --- small hamburger toggle (left) ---
    (function(){
      const btn = document.getElementById('hamburger');
      const panel = document.getElementById('filtersPanel');
      if (!btn || !panel) return;
      btn.addEventListener('click', (e) => {
        const wasHidden = panel.hasAttribute('hidden');
        if (wasHidden) { panel.removeAttribute('hidden'); btn.setAttribute('aria-expanded','true'); }
        else { panel.setAttribute('hidden',''); btn.setAttribute('aria-expanded','false'); }
        e.stopPropagation();
      });
      document.addEventListener('click', (ev) => {
        if (!panel.hasAttribute('hidden') && !panel.contains(ev.target) && ev.target !== btn) {
          panel.setAttribute('hidden',''); btn.setAttribute('aria-expanded','false');
        }
      });
    })();

    // --- Clustering & filtering state ---
    const clusterGroup = L.markerClusterGroup();
    const bounds = L.latLngBounds();
    let allRows = [];
    let allMarkers = [];

    function buildPopup(row) {
      const addr = [row['Address Line 1'], row['City'], row['State/Province/Region'], row['Country']]
        .filter(Boolean).join(', ');
      const phone = row['Phone'] ? `<br>${row['Phone']}` : '';
      return `<div class="popup"><b>${row['Name'] || ''}</b><br>${addr}${phone}</div>`;
    }

    function applyFilter(brand) {
      clusterGroup.clearLayers();
      const brandValue = (brand || '').trim().toUpperCase();
      const typeValue = (document.getElementById('typeFilter').value || 'all');
      const storeInput = (document.getElementById('storeFilter').value || '').trim();
      const storeFilter = storeInput.toLowerCase();

      allMarkers.forEach(({ row, marker }) => {
        let show = true;

        // brand filter
        if (brandValue) {
          const brands = (row['Custom Brands'] || '')
            .toUpperCase()
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
          show = brands.includes(brandValue);
        }

        // store filter: support 'handle:XYZ' exact match, or substring match against Name
        if (storeFilter) {
          if (storeFilter.startsWith('handle:')) {
            const h = storeFilter.split(':', 2)[1] || '';
            show = show && (String(row['Handle'] || '') === h);
          } else {
            show = show && ((String(row['Name'] || '') || '').toLowerCase().includes(storeFilter));
          }
        }

        // type filter: row._type is set at load time ("accessory" or "retailer")
        if (typeValue && typeValue !== 'all') {
          show = show && (String(row._type || 'retailer') === typeValue);
        }

        if (show) clusterGroup.addLayer(marker);
      });
    }

    let radiusCircle = null;

    function meters(mi) { return mi * 1609.344; }

    function showWithinRadius(centerLL, radiusMeters) {
      // Clear circle if any
      if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
      radiusCircle = L.circle(centerLL, { radius: radiusMeters, fillOpacity: 0.07 }).addTo(map);

      // Filter which markers to display within radius (without losing the original set)
      clusterGroup.clearLayers();
      let count = 0;
      allMarkers.forEach(({ marker }) => {
        const d = map.distance(centerLL, marker.getLatLng());
        if (d <= radiusMeters) { clusterGroup.addLayer(marker); count++; }
      });

      setNearMeStatus(`Showing ${count} location(s) within ${(radiusMeters/1609.344).toFixed(0)} mi`);
      if (count > 0) map.fitBounds(radiusCircle.getBounds().pad(0.2));
    }

    function locateAndFilterWithinRadius() {
      if (!navigator.geolocation) { setNearMeStatus('Geolocation not supported.'); return; }
      setNearMeStatus('Locating‚Ä¶');
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const ll = toLatLng(pos.coords.latitude, pos.coords.longitude);
          showUserMarker(ll);
          const mi = parseFloat(document.getElementById('nearMeRadius').value || '10');
          showWithinRadius(ll, meters(mi));
        },
        () => setNearMeStatus('Unable to get location.'),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
      );
    }

    // --- Near Me helpers ---
    let userMarker = null
    let nearestLine = null;
    let nearestMarker = null;

    function setNearMeStatus(msg) {
      const el = document.getElementById('nearMeStatus');
      if (el) el.textContent = msg || '';
    }

    function toLatLng(lat, lng) { return L.latLng(lat, lng); }

    function findNearest(targetLatLng) {
      let best = null; // { dist, row, marker }
      allMarkers.forEach(({ row, marker }) => {
        const d = map.distance(targetLatLng, marker.getLatLng());
        if (!best || d < best.dist) best = { dist: d, row, marker };
      });
      return best;
    }

    function emphasizeNearest(userLL, best) {
      if (nearestLine) { map.removeLayer(nearestLine); nearestLine = null; }
      if (nearestMarker) { nearestMarker.setZIndexOffset(0); nearestMarker = null; }
      if (!best) { setNearMeStatus('No locations loaded.'); return; }

      nearestMarker = best.marker;
      nearestMarker.setZIndexOffset(1000);
      nearestLine = L.polyline([userLL, best.marker.getLatLng()], { weight: 3, dashArray: '6,6' }).addTo(map);

      const miles = (best.dist / 1609.344).toFixed(2);
      const km = (best.dist / 1000).toFixed(2);
      const b = L.latLngBounds([userLL, best.marker.getLatLng()]).pad(0.4);
      map.fitBounds(b);

      setNearMeStatus(`Closest: ${(best.row['Name'] || 'Location')} ‚Äî ${miles} mi / ${km} km`);
      best.marker.openPopup();
    }

    function showUserMarker(ll) {
      if (userMarker) userMarker.setLatLng(ll);
      else userMarker = L.marker(ll, { title: 'You are here' })
      .bindPopup('<b>You are here</b>')
      .addTo(map);

      L.circle(ll, { radius: 25, stroke: false, fillOpacity: 0.15 }).addTo(map);
    }

    function locateAndJumpToNearest() {
      if (!navigator.geolocation) { setNearMeStatus('Geolocation not supported.'); return; }
      setNearMeStatus('Locating‚Ä¶');
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const ll = toLatLng(pos.coords.latitude, pos.coords.longitude);
          showUserMarker(ll);
          const best = findNearest(ll);
          emphasizeNearest(ll, best);
        },
        (err) => {
          const m = {1:'Permission denied.',2:'Position unavailable.',3:'Request timed out.'};
          setNearMeStatus(m[err.code] || 'Unable to get location.');
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
      );
    }

    function populateBrandSelect(brandSet) {
      const sel = document.getElementById('brandFilter');
      while (sel.options.length > 1) sel.remove(1);
      [...brandSet].sort().forEach(b => {
        const opt = document.createElement('option');
        opt.value = b; opt.textContent = b; sel.appendChild(opt);
      });
      sel.onchange = () => applyFilter(sel.value);
      // wire type select
      const typeSel = document.getElementById('typeFilter');
      typeSel.onchange = () => applyFilter(sel.value);
      // wire store filter input (debounced)
      const storeInput = document.getElementById('storeFilter');
      let debounce;
      storeInput.addEventListener('input', () => {
        clearTimeout(debounce);
        debounce = setTimeout(() => applyFilter(sel.value), 250);
      });
    }

    function showBanner(msg) {
      const div = document.createElement('div');
      div.className = 'banner';
      div.textContent = msg;
      document.body.appendChild(div);
    }

    // --- Load data & render (with helpful logs) ---
    loadCSV('locations.csv')
      .then(rows => {
        console.log('CSV rows (raw):', rows.length);
        const brandSet = new Set();

        // Keep only rows that *have something* in lat/lon
        allRows = rows.filter(r => (r.Latitude ?? '') !== '' && (r.Longitude ?? '') !== '');
        console.log('Rows with any lat/lon value:', allRows.length);

        allRows.forEach(row => {
          // classify row as 'accessory' or 'retailer' using simple heuristics
          // - if any descriptive field contains the word 'accessor' treat as accessory
          // - otherwise default to retailer
          const descFields = [row['Name'], row['Page Description'], row['Page Title'], row['Meta Description'], row['Tags'], row['Custom Brands']].filter(Boolean).join('\n');
          const descLower = String(descFields).toLowerCase();
          row._type = /accessor/.test(descLower) || /accessories/.test(descLower) ? 'accessory' : 'retailer';

          const lat = parseFloat(String(row.Latitude).trim());
          const lon = parseFloat(String(row.Longitude).trim());
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

          const marker = L.marker([lat, lon]).bindPopup(buildPopup(row));
          allMarkers.push({ row, marker });
          clusterGroup.addLayer(marker);
          bounds.extend([lat, lon]);

          (row['Custom Brands'] || '')
            .split(',')
            .map(s => s.trim())
            .filter(Boolean)
            .forEach(b => brandSet.add(b));
          // also expose type values for debugging / UI
          // (we don't include types in the brand list)
        });

        map.addLayer(clusterGroup);
        if (bounds.isValid()) map.fitBounds(bounds.pad(0.2));

        populateBrandSelect(brandSet);
        const nearBtn = document.getElementById('nearMeBtn');
        if (nearBtn) nearBtn.addEventListener('click', locateAndJumpToNearest);

        console.log('Markers added:', allMarkers.length);
        if (allMarkers.length === 0) {
          showBanner('No markers loaded ‚Äî check that locations.csv has data rows with numeric Latitude/Longitude.');
        }
      })
      .catch(err => {
        console.error('Error loading CSV:', err);
        alert('Failed to load locations.csv. Serve via http://localhost and ensure the CSV sits next to prototype.html.');
      });
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Prototype Map for 485</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />


  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- PapaParse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- MarkerCluster plugin -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Cormorant font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Cormorant:wght@400;500;600;700&display=swap">
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <header id="sidebar">

    <div id="top">
      <div id="inner">
        <h2>WatchDNA's Network | Find jewellers in your area</h2>
        <p>As your trusted directory for brands and authorized dealers, we make it easy to find and reach out to
          Authorized Dealers. (Please note that only select authorized dealers will be featured under our brand
          filters.)
        </p>
      </div>
    </div>

    <button id="hamburger" aria-expanded="false" aria-controls="filtersPanel" title="Show filters">
      ‚ò∞ Filter
    </button>
    <div id="filtersPanel" class="filters-panel" hidden>
      <label for="brandFilter"><strong>Filter by brand:</strong></label>
      <select id="brandFilter">
        <option value="">All brands</option>
      </select>
      <label for="typeFilter" style="margin-left:12px"><strong>Type:</strong></label>
      <select id="typeFilter" style="padding:8px;">
        <option value="all">All</option>
        <option value="retailer">Retailers</option>
        <option value="boutique">Boutiques</option>
        <option value="mall location">Mall Locations</option>
        <option value="other">Other</option>
      </select>
      <label for="storeFilter" style="margin-left:12px"><strong>Filter by store:</strong></label>
      <input id="storeFilter" type="search" placeholder="Search By Store Name" style="padding:8px; min-width:260px;" />
      <div id="storeCheckboxes"
        style="display:none; margin-top:10px; max-height:200px; overflow-y:auto; border:1px solid var(--border); padding:8px; border-radius:6px;">
        <!-- Store name checkboxes (hidden until user searches) -->
      </div>
        <input type="checkbox" id="premiumOnlyToggle" style="cursor:pointer; transform: scale(1.2);" />
        <label for="premiumOnlyToggle" style="cursor:pointer;"><strong>Show Premium Only</strong></label>
      </div>
      <div style="margin-top:10px; display:flex; align-items:center; gap:8px;"></div>
      <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
        <button id="nearMeBtn" title="Share your location to find the closest store"
          style="padding:8px 10px; border:1px solid var(--border); border-radius:6px; cursor:pointer;">
          üìç Near me
        </button>
        <span id="nearMeStatus" style="font-size:.9rem; opacity:.8;"></span>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <select id="nearMeRadius" style="padding:6px; border:1px solid var(--border); border-radius:6px;">
          <option value="5">5 mi</option>
          <option value="10" selected>10 mi</option>
          <option value="25">25 mi</option>
          <option value="50">50 mi</option>
        </select>
        <button id="nearMeWithinBtn" title="Show stores within radius"
          style="padding:8px 10px; border:1px solid var(--border); border-radius:6px; cursor:pointer;">
          Within radius
        </button>
      </div>
    </div>

    <!-- Store detail panel (hidden by default)-->
     <div id="storeDetailPanel" class="store-detail hidden" aria-hidden="true">
      <div class="store-detail__top">
        <div class="store-detail__title" id="detailName">Store Name</div>
        <button class="store-detail__close" id="detailCloseBtn" aria-label="Close">√ó</button>
      </div>

      <div class="store-detail__image" id="detailImage" role="img" aria-label="Store image placeholder">
        <div class="store-detail__imageText">Image placeholder</div>
      </div>

      <div class="store-detail__actions">
        <a id="detailDirectionsBtn" class="store-detail__btn" href="#" target="_blank" rel="noopener">Directions</a>
        <a id="detailConnectBtn" class="store-detail__btn" href="#">Connect</a>
      </div>

      <div class="store-detail__section">
        <div class="store-detail__label">Address</div>
        <div class="store-detail__value" id="detailAddress"></div>
      </div>

      <div class="store-detail__section">
        <div class="store-detail__label">Phone</div>
        <div class="store-detail__value" id="detailPhone"></div>
      </div>

      <div class="store-detail__section" id="detailAboutSection">
        <div class="store-detail__label">Information</div>
        <div class="store-detail__value" id="detailAbout"></div>
      </div>

      <div class="store-detail__section" id="detailBrandsSection">
        <div class="store-detail__label">Brands</div>
        <div class="store-detail__value" id="detailBrands"></div>
      </div>


    <div id="storeListContainer">
      <div id="storeListings"></div>
    </div>

    <div id="footer">
      <a href="https://watchdna.com/tools/storelocator/directory">Store Directory</a>
    </div>

  </header>

  <div id="map"></div>

  <script>
    // --- Map bootstrap ---
    const map = L.map('map');
    map.setView([20, 0], 2); // will be replaced by fitBounds if we have data

    // Default zoom out logic. Will be used if user did not use Near Me features
    const originalCenter = map.getCenter();
    const originalZoom = map.getZoom();

    map.on('popupclose', () => {
      if(radiusCircle) {
        setDetailPanelVisible(false);
        map.fitBounds(radiusCircle.getBounds().pad(0.2));
      } else {
        // Reset to default zoom
        resetFocusedStore();
      }
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // --- URL parameter helpers (CSV + initial filters) ---
    const params = new URLSearchParams(window.location.search);
    const INITIAL = {
      brand: params.get('brand') || '',
      type: params.get('type') || 'all',
      store: params.get('store') || ''
    };
    console.log('[proto] initial filters:', INITIAL);

    // --- CSV loader (with cache-busting to avoid stale results) ---
    function loadCSV(path) {
      const url = `${path}?v=${Date.now()}`;
      return new Promise((resolve, reject) => {
        Papa.parse(url, {
          download: true,
          header: true,
          skipEmptyLines: true,
          complete: res => resolve(res.data),
          error: err => reject(err)
        });
      });
    }

    // --- small hamburger toggle (left) ---
    (function () {
      const btn = document.getElementById('hamburger');
      const panel = document.getElementById('filtersPanel');
      const storeListContainer = document.getElementById('storeListContainer');

      if (!btn || !panel || !storeListContainer) {
        console.warn('Toggle init aborted, missing elements:', { btn, panel, storeListContainer });
        return;
      }

      function setStoreListHidden(hidden) {
        // keep a class for CSS transitions or style hooks
        if (hidden) {
          storeListContainer.classList.add('hidden');
          //set inline style to be extra sure
          storeListContainer.style.display = 'none';
        }
        else {
          storeListContainer.classList.remove('hidden');
          storeListContainer.style.display = '';
        }
        console.log('[storeList] set hidden =', hidden, 'classList:', storeListContainer.className);
      }

      btn.addEventListener('click', (e) => {
        const wasHidden = panel.hasAttribute('hidden');

        if (wasHidden) {
          //opening the Filters panel
          panel.removeAttribute('hidden');
          btn.setAttribute('aria-expanded', 'true');
          setStoreListHidden(true); //hide the store list
        }
        else {
          //closing the Filters panel
          panel.setAttribute('hidden', '');
          btn.setAttribute('aria-expanded', 'false');
          setStoreListHidden(false); //show the store list
          // Clear the store search when closing the panel
          const storeInput = document.getElementById('storeFilter');
          if (storeInput) {
            storeInput.value = '';
            applyFilter(document.getElementById('brandFilter').value);
          }
        }
        e.stopPropagation();
      });
      document.addEventListener('click', (ev) => {
        if (!panel.hasAttribute('hidden') && !panel.contains(ev.target) && ev.target !== btn) {
          panel.setAttribute('hidden', '');
          btn.setAttribute('aria-expanded', 'false');
          setStoreListHidden(false);
          // Clear the store search when closing the panel by clicking outside
          const storeInput = document.getElementById('storeFilter');
          if (storeInput) {
            storeInput.value = '';
            applyFilter(document.getElementById('brandFilter').value);
          }
          console.log('[document] closed filters by click outside');
        }
      });
    })();

    // --- Clustering & filtering state ---
    const clusterGroup = L.markerClusterGroup();
    const bounds = L.latLngBounds();
    let allRows = [];
    let allMarkers = [];
    // Keep track of stores the user has explicitly checked (lowercased names)
    let userCheckedStores = new Set();

    // Temporary Icons for regular and premium vendors
    const regularIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34]
    });

    const premiumIcon = L.icon({
      iconUrl: 'assets/markers/watchdna_clear_pin.png',
      iconSize: [64, 64],
      iconAnchor: [32, 64],
      popupAnchor: [0, -56]
    });

    function buildPopup(row) {
      const addr = [row['Address Line 1'], row['City'], row['State/Province/Region'], row['Country']]
        .filter(Boolean).join(', ');
      const phone = row['Phone'] ? `<br>${row['Phone']}` : '';
      
      // Get brands from Brands column first, fallback to Custom Brands if empty
      let brands = (row['Brands'] || '').trim();
      if (!brands && row['Custom Brands']) {
        // Extract brand names from HTML Custom Brands column
        const customBrandsHtml = row['Custom Brands'];
        const brandMatches = customBrandsHtml.match(/>([^<]+)<\/A>/gi) || [];
        brands = brandMatches.map(m => m.replace(/>|<\/A>/gi, '').trim()).filter(Boolean).join(', ');
      }
      
      const displayBrands = getDisplayBrandsForRow(row);
      const brandsDisplay = displayBrands
      ? `<br><br><strong>Brands:</strong> ${displayBrands}`
      : '';
      return `<div class="popup"><b>${row['Name'] || ''}</b><br>${addr}${phone}${brandsDisplay}</div>`;
    }
    
    function buildFullAddress(row) {
      const line1 = (row['Address Line 1'] || '').trim();
      const line2 = (row['Address Line 2'] || '').trim();
      const city = (row['City'] || '').trim();
      const state = (row['State/Province/Region'] || '').trim();
      const zip = (row['Zip/Postal Code'] || '').trim();
      const country = (row['Country'] || '').trim();
      
      const parts = [];
      if (line1) parts.push(line1);
      if (line2) parts.push(line2);
      
      const cityLine = [city, state, zip].filter(Boolean).join(', ');
      if (cityLine) parts.push(cityLine);
      if (country) parts.push(country);
      
      return parts.join('\n');
    }

    // Brand level paid visibility (demo)
    // A brand can approve up to 'maxApproved' locations to show that brand even if the location isnt verified
     const BRAND_VISIBILITY_CONFIG = {
      "OMEGA": {
        maxApproved: 5,
        approvedHandles: ["7426", "6416", "3229", "6917170001", "O1825152"]
      }
    };

    function normalizeKey(val) {
      return String(val || "").trim().toLowerCase();
    }

    function isLocationApprovedForBrand(row, brandName) {
      const cfg = BRAND_VISIBILITY_CONFIG[String(brandName || "").toUpperCase()];
      if (!cfg) return false;

      const maxApproved = Number(cfg.maxApproved || 0);
      const approvedCount =
        (cfg.approvedHandles?.length || 0) + (cfg.approvedNames?.length || 0);
      
      if (maxApproved > 0 && approvedCount > maxApproved) {
      }

      const handle = normalizeKey(row["Handle"]);
      const name = normalizeKey(row["Name"]);

      const handleApproved = (cfg.approvedHandles || [])
        .slice(0, maxApproved || undefined)
        .some(h => normalizeKey(h) === handle);

      const nameApproved = (cfg.approvedNames || [])
        .slice(0, maxApproved || undefined)
        .some(n => normalizeKey(n) === name);

      return handleApproved || nameApproved;
    }

    function getDisplayBrandsForRow(row) {
      const fullBrands = extractBrandsText(row);
      const list = fullBrands
      .split(",")
      .map(s => s.trim())
      .filter(Boolean);

      if (row._isPremium) return list.join(", ");

      // Unverified: only show brands that approved this location
      const allowed = list.filter(b => isLocationApprovedForBrand(row, b));
      return allowed.join(", ");
    }

    
    function extractBrandsText(row) {
      let brands = (row['Brands'] || '').trim();
      
      if (!brands && row['Custom Brands']) {
        const customBrandsHtml = row['Custom Brands'];
        const brandMatches = customBrandsHtml.match(/>([^<]+)<\/A>/gi) || [];
        brands = brandMatches
        .map(m => m.replace(/>|<\/A>/gi, '').trim())
        .filter(Boolean)
        .join(', ');
      }
      
      return brands;
    }

    function setDetailPanelVisible(visible) {
      const sidebar = document.getElementById('sidebar');
      const panel = document.getElementById('storeDetailPanel');
      const listContainer = document.getElementById('storeListContainer');
      if (!sidebar || !panel || !listContainer) return;

      if (visible) {
      sidebar.classList.add('store-focused');
      panel.classList.remove('hidden');
      panel.setAttribute('aria-hidden', 'false');
      //listContainer.classList.add('hidden');
      //listContainer.style.display = 'none';
    } else {
      sidebar.classList.remove('store-focused');
      panel.classList.add('hidden');
      panel.setAttribute('aria-hidden', 'true');
      //listContainer.classList.remove('hidden');
      //listContainer.style.display = '';
    }
  }

  function openStoreDetail(row, marker) {
    const nameEl = document.getElementById('detailName');
    const addressEl = document.getElementById('detailAddress');
    const phoneEl = document.getElementById('detailPhone');
    const brandsEl = document.getElementById('detailBrands');
    const brandsSectionEl = document.getElementById('detailBrandsSection');
    const imageEl = document.getElementById('detailImage');
    const directionsBtn = document.getElementById('detailDirectionsBtn');
    const connectBtn = document.getElementById('detailConnectBtn');
    const aboutSectionEl = document.getElementById('detailAboutSection');
    const aboutEl = document.getElementById('detailAbout');

    const name = (row['Name'] || 'Unnamed').trim();
    const address = buildFullAddress(row);
    const phone = (row['Phone'] || '').trim();
    const brands = getDisplayBrandsForRow(row);

    if (nameEl) nameEl.textContent = name;

    if (addressEl) {
      addressEl.textContent = address || 'Not provided';
      addressEl.style.whiteSpace = 'pre-line';
    }

    if (phoneEl) phoneEl.textContent = phone || 'Not provided';
    const isVerified = !!row._isPremium;

    const aboutText =
      "We are building a vibrant community where watch enthusiasts can discover new brands and connect with passionate jewellers who value both timepieces and the stories behind them. As your trusted directory for brands and authorized dealers, we make it easy to find and reach out to reputable retailers. Feel free to contact your authorized dealer for any questions regarding the brands they carry.";

    if (aboutSectionEl) {
      aboutSectionEl.style.display = isVerified ? "" : "none";
    }

    if (aboutEl) {
      aboutEl.textContent = isVerified ? aboutText : "";
    }

    // Image: show only for premium/verified
    if (imageEl) {
      if (isVerified) {
        imageEl.style.display = '';
        const imageUrl = (row['Image URL'] || '').trim();

        if (imageUrl) {
          imageEl.style.backgroundImage = `url('${imageUrl}')`;
          imageEl.style.backgroundSize = 'cover';
          imageEl.style.backgroundPosition = 'center';

          const imageText = imageEl.querySelector('.store-detail__imageText');
          if (imageText) imageText.style.display = 'none';
        } else {
          imageEl.style.backgroundImage = '';
          const imageText = imageEl.querySelector('.store-detail__imageText');
          if (imageText) imageText.style.display = '';
        }
      } else {
        imageEl.style.backgroundImage = '';
        imageEl.style.display = 'none';
      }
    }

    // Brands: show only for premium/verified
    const hasVisibleBrands = !!brands;

    if (brandsSectionEl) {
      // Verified: show; Unverified: only show if a brand approved visibility
      brandsSectionEl.style.display = (isVerified || hasVisibleBrands) ? '' : 'none';
    }
    if (brandsEl) {
      if (isVerified) brandsEl.textContent = brands || 'Not provided';
      else brandsEl.textContent = hasVisibleBrands ? brands : '';
    }

    

    // Directions: use lat/lng if available, otherwise fall back to address
    const lat = parseFloat(String(row.Latitude || '').trim());
    const lon = parseFloat(String(row.Longitude || '').trim());
    const hasCoords = Number.isFinite(lat) && Number.isFinite(lon);

    if (directionsBtn) {
    const q = hasCoords ? `${lat},${lon}` : encodeURIComponent(address.replace(/\n/g, ', '));
    directionsBtn.href = hasCoords
      ? `https://www.google.com/maps/search/?api=1&query=${q}`
      : `https://www.google.com/maps/search/?api=1&query=${q}`;
    }

    // Connect: prefer email; otherwise disable
    const email = (row['Email'] || '').trim();
    if (connectBtn) {
      if (isValidEmail(email)) {
        connectBtn.href = `mailto:${email}`;
        connectBtn.textContent = 'Connect';
        connectBtn.style.opacity = '1';
        connectBtn.style.pointerEvents = 'auto';
      } else {
        connectBtn.href = '#';
        connectBtn.textContent = 'Connect';
        connectBtn.style.opacity = '0.5';
        connectBtn.style.pointerEvents = 'none';
      }
    }
    
    setDetailPanelVisible(true);

    // Optional: keep the map movement consistent
    if (marker && hasCoords) {
      map.flyTo([lat, lon], 14, { animate: true, duration: 2.5 });
    }
  }

  //Zooms the map out to full view
  function resetFocusedStore() {
    setDetailPanelVisible(false);

    // Zoom back out to the original field of view
    if(!radiusCircle && originalCenter && originalZoom !== undefined) {
      map.flyTo(originalCenter, originalZoom, {
        animate: true,
        duration: 2.5
      });
    }
  }

  // When the close store detail button is clicked, it will close itself, the popup, and zoom the map back out to full view
  const closeBtn = document.getElementById('detailCloseBtn');
  if(closeBtn) {
    closeBtn.addEventListener('click', () => {
      // Hide the store detail panel (mainly for if radiusCircle is true)
      setDetailPanelVisible(false);

      // Close the popup on the associated map marker
      if (focusedMarker) {
        focusedMarker.closePopup();
        focusedMarker = null; 
      }

      // Zoom out to the appropriate level
      if (radiusCircle) {
        // Near Me/Within Radius has been used
        map.fitBounds(radiusCircle.getBounds().pad(0.2));
      } else {
        // Default zoom
        resetFocusedStore();
      }
    });
  }

    function rebuildStoreCheckboxes(rowsForList) {
      // rowsForList should be the rows after applying non-checkbox filters
      const storeCheckboxesDiv = document.getElementById('storeCheckboxes');

      // start fresh; by default checkboxes should be unchecked so the user
      // explicitly selects any stores they want
      storeCheckboxesDiv.innerHTML = '';

      const storeNames = [...new Set(rowsForList.map(r => (r['Name'] || '').trim()).filter(Boolean))].sort();

      const premiumOnly = document.getElementById('premiumOnlyToggle')?.checked;

      // Remove any previously-checked stores that are no longer present
      const storeNameSet = new Set(storeNames.map(s => s.toLowerCase()));
      Array.from(userCheckedStores).forEach(s => { if (!storeNameSet.has(s)) userCheckedStores.delete(s); });

      storeNames.forEach(name => {
        const rowMatch = rowsForList.find(r => (r['Name'] || '').trim() === name);

        // Skip non-premium rows entirely in checkbox list
        if (premiumOnly && !rowMatch?._isPremium) return;

        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '8px';
        label.style.padding = '2px 0';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = name;
        // restore user selection if previously checked
        cb.checked = userCheckedStores.has(name.toLowerCase());
        cb.addEventListener('change', () => {
          const val = cb.value.toLowerCase();
          if (cb.checked) userCheckedStores.add(val); else userCheckedStores.delete(val);
          applyFilter(document.getElementById('brandFilter').value);
        });

        const span = document.createElement('span');
        span.textContent = name;
        span.style.userSelect = 'none';

        label.appendChild(cb);
        label.appendChild(span);
        storeCheckboxesDiv.appendChild(label);
      });
    }

    // Sync the "Filter by store" checkbox list with the rows that passed ALL filters
    function syncStoreCheckboxes(filteredRows) {
      const allowed = new Set(
        filteredRows.map(r => (r['Name'] || '').trim().toLowerCase())
      );

      const q = (document.getElementById('storeFilter').value || '')
        .trim().toLowerCase();

      // Walk all checkbox rows in the list
      document.querySelectorAll('#storeCheckboxes label').forEach(label => {
        const cb = label.querySelector('input[type="checkbox"]');
        const name = (label.querySelector('span')?.textContent || cb.value || '')
          .trim().toLowerCase();

        const inFiltered = allowed.has(name);

        // Show/hide entries that are not part of the current filtered set
        label.style.display = inFiltered ? '' : 'none';

        // Do not auto-check matches when the user types ‚Äî leave checked state
        // under user control. If an item is no longer in the filtered set,
        // uncheck it and remove it from the user's selection set.
        if (!inFiltered) {
          cb.checked = false;
          userCheckedStores.delete(cb.value.toLowerCase());
        }
      });
    }

    function applyFilter(brand) {
      clusterGroup.clearLayers();

      const brandValue = (brand || '').trim().toUpperCase();
      const typeValue = (document.getElementById('typeFilter').value || 'all');
      const storeInput = (document.getElementById('storeFilter').value || '').trim().toLowerCase();
      // Premium-only filter
      const premiumOnly = document.getElementById('premiumOnlyToggle').checked;

      const baseRows = [];
      allMarkers.forEach(({ row }) => {
        let passes = true;

        // brand filter - check Brands column (plain text, comma-separated)
        if (brandValue) {
          const brands = getDisplayBrandsForRow(row)
            .toUpperCase()
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
          passes = brands.includes(brandValue);
        }

        // store text search
        if (passes && storeInput) {
          if (storeInput.startsWith('handle:')) {
            const h = storeInput.split(':', 2)[1] || '';
            passes = (String(row['Handle'] || '') === h);
          } else {
            passes = (String(row['Name'] || '').toLowerCase().includes(storeInput));
          }
        }

        // type filter
        if (passes && typeValue && typeValue !== 'all') {
          passes = (String(row._type || 'retailer') === typeValue);
        }

        // Premium-only logic
        if (passes && premiumOnly) {
          passes = row._isPremium === true;
        }

        if (passes) baseRows.push(row);
      });

      rebuildStoreCheckboxes(baseRows);
      syncStoreCheckboxes(baseRows);

      // Show checkboxes only when the user has entered a store search
      try {
        const storeCheckboxesDiv = document.getElementById('storeCheckboxes');
        if (storeCheckboxesDiv) {
          storeCheckboxesDiv.style.display = storeInput && storeInput.trim() ? '' : 'none';
        }
      } catch (e) {
        console.warn('Could not toggle storeCheckboxes visibility', e);
      }


      const checkedStores = Array.from(document.querySelectorAll('#storeCheckboxes input[type="checkbox"]:checked')).map(cb => cb.value.toLowerCase());

      const baseNameSet = new Set(baseRows.map(r => (r['Name'] || '').trim().toLowerCase()));

      allMarkers.forEach(({ row, marker }) => {
        const nameLower = (row['Name'] || '').trim().toLowerCase();
        let show = baseNameSet.has(nameLower); // only show if it matched non-checkbox filters

        if (show && checkedStores.length > 0) {
          show = checkedStores.includes(nameLower);
        }

        if (show) clusterGroup.addLayer(marker);
      });

    }

    // --- Near Me radius filter ---

    let radiusCircle = null;

    function meters(mi) { return mi * 1609.344; }

    function applyRadiusToCurrent(centerLL, radiusMeters) {
      if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
      radiusCircle = L.circle(centerLL, { radius: radiusMeters, fillOpacity: 0.07 }).addTo(map);

      // Start from your existing filtered set
      const brandValue = (document.getElementById('brandFilter').value || '');
      applyFilter(brandValue);

      // Filter only visible markers within the radius
      const current = clusterGroup.getLayers();
      clusterGroup.clearLayers();
      let kept = 0;
      current.forEach(m => {
        const d = map.distance(centerLL, m.getLatLng());
        if (d <= radiusMeters) { clusterGroup.addLayer(m); kept++; }
      });

      setNearMeStatus(`Showing ${kept} location(s) within ${(radiusMeters / 1609.344).toFixed(0)} mi`);
      if (kept > 0) map.fitBounds(radiusCircle.getBounds().pad(0.2));
    }

    function locateAndFilterWithinRadius() {
      if (!navigator.geolocation) { setNearMeStatus('Geolocation not supported.'); return; }
      setNearMeStatus('Locating‚Ä¶');
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const ll = toLatLng(pos.coords.latitude, pos.coords.longitude);
          showUserMarker(ll);
          const mi = parseFloat(document.getElementById('nearMeRadius').value || '10');
          applyRadiusToCurrent(ll, meters(mi));
        },
        () => setNearMeStatus('Unable to get location.'),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
      );
    }

    // --- Near Me helpers ---
    let userMarker = null
    let nearestLine = null;
    let nearestMarker = null;

    function setNearMeStatus(msg) {
      const el = document.getElementById('nearMeStatus');
      if (el) el.textContent = msg || '';
    }

    function toLatLng(lat, lng) { return L.latLng(lat, lng); }

    function findNearest(targetLatLng) {
      let best = null; // { dist, row, marker }
      allMarkers.forEach(({ row, marker }) => {
        const d = map.distance(targetLatLng, marker.getLatLng());
        if (!best || d < best.dist) best = { dist: d, row, marker };
      });
      return best;
    }

    function emphasizeNearest(userLL, best) {
      if (nearestLine) { map.removeLayer(nearestLine); nearestLine = null; }
      if (nearestMarker) { nearestMarker.setZIndexOffset(0); nearestMarker = null; }
      if (!best) { setNearMeStatus('No locations loaded.'); return; }

      nearestMarker = best.marker;
      const row = best.row || getRowForMarker(nearestMarker);

      nearestMarker.setZIndexOffset(1000);
      nearestLine = L.polyline([userLL, nearestMarker.getLatLng()], { weight: 3, dashArray: '6,6' }).addTo(map);

      const dist = map.distance(userLL, nearestMarker.getLatLng());
      const miles = (best.dist / 1609.344).toFixed(2);
      const km = (best.dist / 1000).toFixed(2);
      const b = L.latLngBounds([userLL, best.marker.getLatLng()]).pad(0.4);
      map.fitBounds(b);

      setNearMeStatus(`Closest: ${(row['Name'] || 'Location')} ‚Äî ${miles} mi / ${km} km`);
      nearestMarker.openPopup();
    }

    function showUserMarker(ll) {
      if (userMarker) userMarker.setLatLng(ll);
      else userMarker = L.marker(ll, { title: 'You are here' })
        .bindPopup('<b>You are here</b>')
        .addTo(map);

      L.circle(ll, { radius: 25, stroke: false, fillOpacity: 0.15 }).addTo(map);
    }

    // Return the markers currently visible after applyFilter()
    function getVisibleMarkers() {
      return clusterGroup.getLayers(); // array of L.Marker
    }

    // Lookup the original row for a given marker
    function getRowForMarker(marker) {
      const rec = allMarkers.find(x => x.marker === marker);
      return rec ? rec.row : {};
    }

    // Find the nearest marker among a given set (visible layers)
    function findNearestAmong(targetLatLng, layers) {
      let best = null; // { dist, marker }
      layers.forEach(m => {
        const d = map.distance(targetLatLng, m.getLatLng());
        if (!best || d < best.dist) best = { dist: d, marker: m };
      });
      return best;
    }

    function locateAndJumpToNearest() {
      if (!navigator.geolocation) { setNearMeStatus('Geolocation not supported.'); return; }
      setNearMeStatus('Locating‚Ä¶');
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const userLL = toLatLng(pos.coords.latitude, pos.coords.longitude);
          showUserMarker(userLL);

          // Ensure we're using the current filtered set (whatever UI is set to)
          const brandValue = (document.getElementById('brandFilter').value || '');
          applyFilter(brandValue); // keeps current type/store filters

          const visible = getVisibleMarkers();
          if (!visible.length) { setNearMeStatus('No locations match current filters.'); return; }

          const best = findNearestAmong(userLL, visible);
          // Include row for nicer status text
          emphasizeNearest(userLL, { ...best, row: getRowForMarker(best.marker) });
        },
        (err) => {
          const m = { 1: 'Permission denied.', 2: 'Position unavailable.', 3: 'Request timed out.' };
          setNearMeStatus(m[err.code] || 'Unable to get location.');
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
      );
    }

    function populateBrandSelect(brandSet) {
      const sel = document.getElementById('brandFilter');
      while (sel.options.length > 1) sel.remove(1);
      [...brandSet].sort().forEach(b => {
        const opt = document.createElement('option');
        opt.value = b; opt.textContent = b; sel.appendChild(opt);
      });
      sel.onchange = () => applyFilter(sel.value);
      // wire type select
      const typeSel = document.getElementById('typeFilter');
      typeSel.onchange = () => applyFilter(sel.value);
      // wire store filter input (debounced)
      const storeInput = document.getElementById('storeFilter');
      let debounce;
      storeInput.addEventListener('input', () => {
        clearTimeout(debounce);
        debounce = setTimeout(() => applyFilter(sel.value), 250);
      });
    }

    function showBanner(msg) {
      const div = document.createElement('div');
      div.className = 'banner';
      div.textContent = msg;
      document.body.appendChild(div);
    }

    function isValidEmail(val) {
      if (!val) return false;

      const bad = new Set([
        '', ' ', '-', '--', '---', '.', 'n/a', 'na', 'none', 'null',
        'not provided', 'not available', 'no email', '0'
    ]);

    const cleaned = val.trim().toLowerCase();
    if (bad.has(cleaned)) return false;

    return cleaned.includes('@') && cleaned.includes('.');
    }

    // --- Load data & render (with helpful logs) ---
    loadCSV('backend/uploads/master_stores.csv')
      .then(rows => {
        console.log('CSV rows (raw):', rows.length);
        const brandSet = new Set();

        // Keep only rows that *have something* in lat/lon
        allRows = rows.filter(r => (r.Latitude ?? '') !== '' && (r.Longitude ?? '') !== '');
        console.log('Rows with any lat/lon value:', allRows.length);

        const detailCloseBtn = document.getElementById('detailCloseBtn');
        if (detailCloseBtn) {
          detailCloseBtn.addEventListener('click', () => setDetailPanelVisible(false));
        }

        allRows.forEach(row => {
          // classify row as 'accessory' or 'retailer' using simple heuristics
          // - if any descriptive field contains the word 'accessor' treat as accessory
          // - otherwise default to retailer
          const descFields = [row['Name'], row['Page Description'], row['Page Title'], row['Meta Description'], row['Tags'], row['Custom Brands']]
            .filter(Boolean)
            .join('\n')
            .toLowerCase();

          if (/boutique/.test(descFields)) {
            row._type = 'boutique';
          } else if (/mall|shopping center|plaza/.test(descFields)) {
            row._type = 'mall location';
          } else if (/authorized dealer|retailer|store/.test(descFields)) {
            row._type = 'retailer';
          } else {
            row._type = 'other';
          }
          const lat = parseFloat(String(row.Latitude).trim());
          const lon = parseFloat(String(row.Longitude).trim());
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

          row._isPremium = isValidEmail(row['Email']);

          const iconToUse = row._isPremium ? premiumIcon : regularIcon;

          const marker = L.marker([lat, lon], { icon: iconToUse })
            .bindPopup(buildPopup(row));
            marker.on('click', () => {
              focusedMarker = marker;
              openStoreDetail(row, marker);
              });
          allMarkers.push({ row, marker });
          clusterGroup.addLayer(marker);
          bounds.extend([lat, lon]);

          // Extract brands from Brands column (plain text, comma-separated)
          (row['Brands'] || '')
            .split(',')
            .map(s => s.trim())
            .filter(Boolean)
            .forEach(b => brandSet.add(b));
          // also expose type values for debugging / UI
          // (we don't include types in the brand list)

        });

        map.addLayer(clusterGroup);

        const NearMeControl = L.Control.extend({
          options: { position: 'bottomright' },

          onAdd: function (map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
            container.style.backgroundColor = 'white';
            container.style.border = '1px solid #ccc';
            container.style.borderRadius = '6px';
            container.style.cursor = 'pointer';
            container.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
            container.style.padding = '6px 10px';
            container.style.fontSize = '16px';
            container.style.display = 'flex';
            container.style.alignItems = 'center';
            container.style.justifyContent = 'center';
            container.title = 'Find stores near me';
            container.innerHTML = 'üìç Near Me';

            // Prevent map from zooming when clicking the control
            L.DomEvent.disableClickPropagation(container);

            container.addEventListener('click', () => {
              locateAndJumpToNearest();
            });

            return container;
          }
        });

        map.addControl(new NearMeControl());

        if (bounds.isValid()) map.fitBounds(bounds.pad(0.2));

        // Building the sidebar list
        const storeList = document.getElementById('storeListings');
        storeList.innerHTML = '';

        allMarkers.forEach(({ row, marker }) => {
          const item = document.createElement('div');
          item.className = 'store';

          const addressLine = row['Address Line 1'] || '';

          const locationParts = [
            row['City'],
            row['State/Province/Region'],
            row['Country']
          ].filter(Boolean); // Will remove undefined or empty strings (mainly for locations that don't have a State/Province/Region)

          // Join the pieces of the address with commas
          const locationLine = locationParts.join(', ');

          item.innerHTML = `
          <strong>${row['Name'] || 'Unamed'}</strong><br>
          ${addressLine}<br>
          ${locationLine}
          `;

          item.addEventListener('click', () => {
            // Pan to location on map and open its associated popup
            // two lines to add lat and lon to variables but within this function there are already those so just going to use those
            const latitude = parseFloat(row.Latitude);
            const longitude = parseFloat(row.Longitude);

            if (Number.isFinite(latitude) && Number.isFinite(longitude)) {
              map.flyTo([latitude, longitude], 14, { animate: true, duration: 0.8 });
            }

            focusedMarker = marker;
            openStoreDetail(row, marker);
          });

          storeList.appendChild(item);
        });

        const RadiusControl = L.Control.extend({
          options: { position: 'bottomright' },

          onAdd: function (map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
            container.style.backgroundColor = 'white';
            container.style.border = '1px solid #ccc';
            container.style.borderRadius = '6px';
            container.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
            container.style.padding = '8px';
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.gap = '6px';
            container.style.fontSize = '14px';
            container.title = 'Show stores within a radius of your location';

            // Prevent clicks from affecting map zoom/pan
            L.DomEvent.disableClickPropagation(container);

            // Radius dropdown
            const select = L.DomUtil.create('select', '', container);
            select.style.padding = '4px';
            select.style.borderRadius = '4px';
            select.style.border = '1px solid #ccc';
            select.style.cursor = 'pointer';

            [5, 10, 25, 50].forEach(mi => {
              const opt = document.createElement('option');
              opt.value = mi;
              opt.textContent = `${mi} mi`;
              if (mi === 10) opt.selected = true;
              select.appendChild(opt);
            });

            // "Within radius" button
            const button = L.DomUtil.create('button', '', container);
            button.textContent = 'Within radius';
            button.style.padding = '6px 8px';
            button.style.border = '1px solid #ccc';
            button.style.borderRadius = '4px';
            button.style.cursor = 'pointer';
            button.style.background = 'white';

            // Click handler
            button.addEventListener('click', () => {
              const mi = parseFloat(select.value || '10');
              const radiusMeters = mi * 1609.344;

              if (!navigator.geolocation) {
                setNearMeStatus('Geolocation not supported.');
                return;
              }

              setNearMeStatus(`Locating...`);
              navigator.geolocation.getCurrentPosition(
                pos => {
                  const ll = L.latLng(pos.coords.latitude, pos.coords.longitude);
                  showUserMarker(ll);
                  applyRadiusToCurrent(ll, radiusMeters);
                },
                () => setNearMeStatus('Unable to get location.'),
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
              );
            });

            return container;
          }
        });

        map.addControl(new RadiusControl());
        populateBrandSelect(brandSet);
        rebuildStoreCheckboxes(allRows);
        // Premium Only Toggle Listener
        document.getElementById('premiumOnlyToggle')
          .addEventListener('change', () => {
            const premiumOnly = document.getElementById('premiumOnlyToggle').checked;

            // Clear all checkboxes when premium-only is enabled
                if (premiumOnly) {
                  document.querySelectorAll('#storeCheckboxes input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                  });
                  userCheckedStores.clear();
                }

            applyFilter(document.getElementById('brandFilter').value);
          });

        // Preload filters from URL, then apply once
        document.getElementById('brandFilter').value = INITIAL.brand;
        document.getElementById('typeFilter').value = INITIAL.type;
        document.getElementById('storeFilter').value = INITIAL.store;
        applyFilter(INITIAL.brand);

        // Do not pre-check checkboxes from URL params; users must explicitly
        // select stores using the checkbox controls.

        const nearBtn = document.getElementById('nearMeBtn');
        if (nearBtn) nearBtn.addEventListener('click', locateAndJumpToNearest);

        const withinBtn = document.getElementById('nearMeWithinBtn');
        if (withinBtn) withinBtn.addEventListener('click', locateAndFilterWithinRadius);

        console.log('Markers added:', allMarkers.length);
        if (allMarkers.length === 0) {
          showBanner('No markers loaded ‚Äî check that master_stores.csv has data rows with numeric Latitude/Longitude.');
        }
      })
      .catch(err => {
        console.error('Error loading CSV:', err);
        alert('Failed to load master_stores.csv. Serve via http://localhost and ensure the CSV file exists at backend/uploads/master_stores.csv.');
      });
  </script>
</body>

</html>